---
title: '[原]洛谷P1056排座椅 简单模拟'
tags: []
date: 2018-08-23 14:25:48
---

## 题目描述

上课的时候总会有一些同学和前后左右的人交头接耳，这是令小学班主任十分头疼的一件事情。不过，班主任小雪发现了一些有趣的现象，当同学们的座次确定下来之后，只有有限的D对同学上课时会交头接耳。

同学们在教室中坐成了 MMM 行 NNN 列，坐在第i行第j列的同学的位置是 (i,j)(i,j)(i,j) ，为了方便同学们进出，在教室中设置了 KKK 条横向的通道， LLL 条纵向的通道。

于是，聪明的小雪想到了一个办法，或许可以减少上课时学生交头接耳的问题：她打算重新摆放桌椅，改变同学们桌椅间通道的位置，因为如果一条通道隔开了 222 个会交头接耳的同学，那么他们就不会交头接耳了。

请你帮忙给小雪编写一个程序，给出最好的通道划分方案。在该方案下，上课时交头接耳的学生的对数最少。

## 输入输出格式

**输入格式：**

第一行，有 555 个用空格隔开的整数，分别是 M,N,K,L,D(2≤N,M≤1000,0≤K&lt;M,0≤L&lt;N,D≤2000)M,N,K,L,D(2 \le N,M \le 1000,0 \le K&lt;M,0 \le L&lt;N,D \le 2000)M,N,K,L,D(2≤N,M≤1000,0≤K&lt;M,0≤L&lt;N,D≤2000)

接下来的 DDD 行，每行有 444 个用空格隔开的整数。第 iii 行的 444 个整数 Xi,Yi,Pi,QiX_i,Y_i,P_i,Q_iXi​,Yi​,Pi​,Qi​ ，表示坐在位置 (Xi,Yi)(X_i,Y_i)(Xi​,Yi​) 与 (Pi,Qi)(P_i,Q_i)(Pi​,Qi​) 的两个同学会交头接耳（输入保证他们前后相邻或者左右相邻）。

输入数据保证最优方案的唯一性。

**输出格式：**

共两行。

第一行包含 KKK 个整数 a1,a2,…,aKa_1,a_2,…,a_Ka1​,a2​,…,aK​ ，表示第 a1a_1a1​ 行和 a1+1a_1+1a1​+1 行之间、第 a−2a-2a−2 行和 a2+1a_2+1a2​+1 行之间、…、第 aKa_KaK​ 行和第 aK+1a_K+1aK​+1 行之间要开辟通道，其中 ai&lt;ai+1a_i&lt; a_i+1ai​&lt;ai​+1 ，每两个整数之间用空格隔开（行尾没有空格）。

第二行包含 LLL 个整数 b1,b2,…,bLb_1,b_2,…,b_Lb1​,b2​,…,bL​ ，表示第 b1b_1b1​ 列和 b1+1b_1+1b1​+1 列之间、第 b2b_2b2​ 列和 b2+1b_2+1b2​+1 列之间、…、第 bLb_LbL​ 列和第 bL+1b_L+1bL​+1 列之间要开辟通道，其中 bi&lt;bi+1b_i&lt; b_i+1bi​&lt;bi​+1 ，每两个整数之间用空格隔开（列尾没有空格）。

## 输入输出样例

**输入样例#1：** <a>复制</a>

<pre>
4 5 1 2 3
4 2 4 3
2 3 3 3
2 5 2 4
</pre>

**输出样例#1：** <a>复制</a>

<pre>
2
2 4
</pre>

<pre class="has">
`#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;
#define maxn 10000
struct stu
{
	int x, cnt;
};
bool fcmp(stu a, stu b)
{
	return a.cnt&gt;b.cnt;
}
bool cmp(stu a, stu b)
{
	return a.x&lt;b.x;
}
int main()
{
	int m, n, k, l, d, i;
	int x, y, p, q;
	cin&gt;&gt;m&gt;&gt;n&gt;&gt;k&gt;&gt;l&gt;&gt;d;
	stu a[maxn], b[maxn];
	int flag1=0, flag2=0;
	for(i=0; i&lt;d; i++)
	{
		int j;
		scanf("%d%d%d%d", &amp;x, &amp;y, &amp;p, &amp;q);
		if(y==q)
		{
			j = min(x, p);
			a[j].x = j;
			a[j].cnt++;
		}
		else
		{
			j = min(y, q);
			b[j].x = j;
			b[j].cnt++;
		}
	}
	sort(a, a+d, fcmp);
	sort(a, a+k, cmp);
	sort(b, b+d, fcmp);
	sort(b, b+l, cmp);
	for(i=0; i&lt;k; i++)
	{
		if(i) cout&lt;&lt;' ';
		cout&lt;&lt;a[i].x;
	}cout&lt;&lt;endl;
	for(i=0; i&lt;l; i++)
	{
		if(i) cout&lt;&lt;' ';
		cout&lt;&lt;b[i].x;
	}cout&lt;&lt;endl;

	return 0;
}`</pre>

                    <div>
                        作者：Jqmjyj 发表于 2018/08/23 14:25:48 [原文链接](https://blog.csdn.net/Jqmjyj/article/details/81980258) https://blog.csdn.net/Jqmjyj/article/details/81980258                    </div>
                    <div>
                        阅读：115                     </div>