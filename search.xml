<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Tensorflow objcet_detection]]></title>
    <url>%2F2019%2F03%2F24%2FTensorflow%20objcet_detection%2F</url>
    <content type="text"><![CDATA[Tensorflow objcet_detection系统环境 操作系统：Manjaro 18.0.4 with KDE 5.56 内存：8G CPU：Intel i5-8250U GPU：NVIDIA MX150 TensorFlow：1.13 经测试，在以下环境也成功一条龙配置 操作系统：Manjaro 18.0.4 with KDE 5.56 主板：ROG STRIX Z370-H GAMING 内存：32G CPU：Intel i7-8700 GPU：NVIDIA TITAN Xp TensorFlow：1.13 前置安装 python-tensorflow_cuda jupyter-notebook protobuf tk Python库 pip install matplotlib 尝试TensorFlow1234import tensorflow as tfhello = tf.constant('Hello, TensorFlow!')sess = tf.Session()print(sess.run(hello)) 下载objcet_detection并配置github项目链接 下载到本地并解压 cd\解压文件夹 12cd /research/protoc object_detection/protos/*.proto --python_out=. 不产生信息即成功 Try Demo12cd object_detection/jupyter notebook 打开object_detection_tutorial.ipynb 先行运行一次Imports代码块 从头开始运行代码块 脱离Jupyter Notebook在本地单独运行123cd ..#进入research文件夹sudo python setup.py install https://www.cnblogs.com/ying-chease/p/10560327.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[Nim博弈]]></title>
    <url>%2F2019%2F03%2F23%2FNim%E5%8D%9A%E5%BC%88%2F</url>
    <content type="text"><![CDATA[Nim博弈问题描述 有三堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 问题分析C. Bouton证明了以下定理 在正常的Nim游戏中，当且仅当堆的大小的nim-sum非零时，进行第一次移动的玩家才具有获胜策略。否则，第二个玩家有一个获胜策略。 nim-sum即每堆的大小的异或和。 证明： 注意，nim-sum（⊕）通常服从加法交换律，还满足一个附加属性，X ⊕ X = 0。设x 1，…， x n是移动前堆的大小，y 1，…， y n是移动后的相应大小。让$s = x_1 \bigoplus … \bigoplus x_n​$ 和 $t = y_1 \bigoplus … \bigoplus y_n​$。假设一次移动在堆k中，则对于所有i ≠ k，我们有$x_i = y_i​$，并且$x_k &gt; y_k​$。根据上面提到的异或的属性，我们有 123456789&gt; t = 0 ⊕ t&gt; = s ⊕ s ⊕ t&gt; = s ⊕ (x1 ⊕ ... ⊕ xn) ⊕ (y1 ⊕ ... ⊕ yn)&gt; = s ⊕ (x1 ⊕ y1) ⊕ ... ⊕ (xn ⊕ yn)&gt; = s ⊕ 0 ⊕ ... ⊕ 0 ⊕ (xk ⊕ yk) ⊕ 0 ⊕ ... ⊕ 0&gt; = s ⊕ xk ⊕ yk&gt; &gt; (*) t = s ⊕ xk ⊕ yk&gt; 通过以下两个引理的归纳。 lemma 1 如果s = 0，则无论采取何种移动，t ≠ 0。 证明：如果没有可能的移动，则引理是空真(vacuously true)（第一个玩家按照定义无法进行正常的游戏），即由于前件为假导致结果为真。否则，对堆k的任何操作将产生$t = x_k \bigoplus y_k​$。该数字非零，因为$x_k \neq y_k​$。 Lemma 2 如果s ≠ 0，则可以进行移动以使t = 0。 证明：设d是s的二进制表示中最左边（最高有效）非零位的位置，并选择堆k使得$x_k$的第d位也非零。（这样的k必须存在，否则s的第d位将为0）然后让 $y_k = s \bigoplus x_k$，我们可以知道 $y_k &lt; x_k$：在 $x_k$ 和 $y_k$ 中第d位左边所有位是一样的，位d从1减小为0（将值减小 $2^d$），其余位的任何变化最多为 $2^d$-1。第一个玩家可以从第k堆中拿出$x_k-y_k$个物品，然后 1234&gt; t = s ⊕ xk ⊕ yk&gt; = s ⊕ xk ⊕ (s ⊕ xk)&gt; = 0&gt; 由于最后一个人是$s\neq 0$,$t = 0$的情况，那么只要保证最初是 lemma2的$s\neq 0$,$t = 0 ，在lemma2（第一个人）和lemma1（第二个人）交替多次后，必然是第一个人得到最终的胜利。反正若是lemma1为初始状态，则第二人将胜利。 P.S. 此定理仅在有堆的大小为2或大于2时成立 范例问题problemHDU1907 John Time Limit: 5000/1000 MS (Java/Others) Memory Limit: 65535/32768 K (Java/Others)Total Submission(s): 6413 Accepted Submission(s): 3698 Problem Description Little John is playing very funny game with his younger brother. There is one big box filled with M&amp;Ms of different colors. At first John has to eat several M&amp;Ms of the same color. Then his opponent has to make a turn. And so on. Please note that each player has to eat at least one M&amp;M during his turn. If John (or his brother) will eat the last M&amp;M from the box he will be considered as a looser and he will have to buy a new candy box. Both of players are using optimal game strategy. John starts first always. You will be given information about M&amp;Ms and your task is to determine a winner of such a beautiful game. Input The first line of input will contain a single integer T – the number of test cases. Next T pairs of lines will describe tests in a following format. The first line of each test will contain an integer N – the amount of different M&amp;M colors in a box. Next line will contain N integers Ai, separated by spaces – amount of M&amp;Ms of i-th color. Constraints:1 &lt;= T &lt;= 474,1 &lt;= N &lt;= 47,1 &lt;= Ai &lt;= 4747 Output Output T lines each of them containing information about game winner. Print “John” if John will win the game or “Brother” in other case. Sample Input 123456&gt; 2&gt; 3&gt; 3 5 1&gt; 1&gt; 1&gt; Sample Output 123&gt; John&gt; Brother&gt; answer1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;int main()&#123; int t,n,a,sum,s; scanf("%d",&amp;t); while(t--) &#123; sum=0; s=0; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) &#123; scanf("%d",&amp;a); s^=a; sum+=a; &#125; if(sum==n)//所有堆大小都为1 &#123; if(sum%2==0) printf("John\n"); else printf("Brother\n"); &#125; else &#123; if(s==0) printf("Brother\n"); else printf("John\n"); &#125; &#125; return 0;&#125; 问题扩展如果Nim游戏中的规则稍微变动一下,每次最多只能取K个,怎么处理? 方法是将每堆石子数mod (k+1).]]></content>
  </entry>
  <entry>
    <title><![CDATA[Manjaro的配置]]></title>
    <url>%2F2019%2F03%2F08%2FManjaro%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[为什么使用ManjaroManjaro基于arch linux，使用pacman进行软件包管理，非常方便，重点是我觉得ustc的源还挺快的 安装之后的配置怎么安装就不介绍了，相较于纯种的arch，Manjaro最大的好处就是傻瓜安装，建议刻录时使用 Ercher 或者 Rufus的dd模式 或者 UltraIso的RAW模式 获取镜像源sudo pacman-mirrors -g 升级系统sudo pacman -Syyu 配置源sudo pacman-mirrors -i -c China -m rank 选择T大的源，最近好像有点问题，也可以使用USTC的源，速度也还行 增加cn库 1echo -e "\n[archlinuxcn]\nSigLevel = TrustAll\nServer = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/\$arch\n\n[antergos]\nSigLevel = TrustAll\nServer = https://mirrors.tuna.tsinghua.edu.cn/antergos/\$repo/\$arch\n"|sudo tee -a /etc/pacman.conf 签名 1sudo pacman -S --noconfirm archlinuxcn-keyring antergos-keyring]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于hexo博客]]></title>
    <url>%2F2019%2F02%2F20%2F%E5%85%B3%E4%BA%8Ehexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[关于hexo的文章网上已经很多了，我这里也不想再写 主要放3个bat 本地调试12@echo offhexo clean &amp;&amp; hexo s 上传12@echo offhexo clean &amp;&amp; hexo d &amp;&amp; pause 新文章123@echo offset /p t=title: hexo new %t% 保存为.bat放在hexo主目录即可]]></content>
  </entry>
  <entry>
    <title><![CDATA[概率论与数理统计_复习]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[第一章 随机事件及其概率随机试验和样本空间 随机试验（实验）E 相同条件下重复进行 结果不止一个，事先明确却所有可能结果 试验前不能明确哪一个结果出现 样本空间 样本空间Ω 随机试验的一切可能结果组成的集合， 样本点ω 样本空间的元素，即E的每个结果 随机事件 随机事件（事件） 试验E的样本空间Ω的自己为E的随机事件 由一个样本点组成的单电机，称为基本事件 事件间的关系与运算 包含关系 相等关系 和事件 至少一个发生 积事件 同时发生 互不相认事件 不能同时发生 差事件 A-B = {} 随机变量 离散型随机变量 二项分布 泊松分布 几何分布 （柯西分布） 连续型随机变量 平均分布 指数分布 正态分布]]></content>
  </entry>
  <entry>
    <title><![CDATA[V2Ray]]></title>
    <url>%2F2019%2F01%2F07%2FV2Ray%2F</url>
    <content type="text"><![CDATA[默认配置文件（不是我的） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#123; "inbounds": [&#123; "port": 10152, "protocol": "vmess", "settings": &#123; "clients": [ &#123; "id": "xxxxxbc5-xxxx-xxxx-88f5-a8a479xxxxxx", "level": 1, "alterId": 64 &#125; ] &#125;, "streamSettings": &#123; "network": "mkcp", //此处的 mkcp 也可写成 kcp，两种写法是起同样的效果 "kcpSettings": &#123; "mtu": 1350, "tti": 20, "uplinkCapacity": 5, "downlinkCapacity": 100, "congestion": true, //是否启用拥塞控制，默认值为 false "readBufferSize": 1, "writeBufferSize": 1, "header": &#123; "type": "wechat-video" //伪装为微信视频，默认为none &#125; &#125; &#125; &#125;], "outbounds": [&#123; "protocol": "freedom", "settings": &#123;&#125; &#125;,&#123; "protocol": "blackhole", "settings": &#123;&#125;, "tag": "blocked" &#125;], "routing": &#123; "rules": [ &#123; "type": "field", "ip": ["geoip:private"], "outboundTag": "blocked" &#125; ] &#125;&#125; 修改配置文件 1nano /etc/v2ray/config.json 启动、停止、重启V2Ray123systemctl start v2raysystemctl stop v2raysystemctl restart v2ray 查看状态1systemctl status v2ray]]></content>
  </entry>
  <entry>
    <title><![CDATA[西方经济学_宏观]]></title>
    <url>%2F2019%2F01%2F06%2F%E8%A5%BF%E6%96%B9%E7%BB%8F%E6%B5%8E%E5%AD%A6-%E5%AE%8F%E8%A7%82%2F</url>
    <content type="text"><![CDATA[宏观经济的基本指标及其衡量GDP的定义 国内生产总值是指经济社会（即一国或一地区）在一定时期内运用生产要素所生产的全部最终产品（产品和劳务）的市场价值 按地域划分 GNP的定义 国民生产总值是一个国家（或地区）所有常住单位在一定时期（通常为一年）内收入初次分配的最终结果。是一定时期内本国的生产要素所有者所占有的最终产品和服务的总价值。等于国内生产总值加上来自国内外的净要素收入。 按国籍划分 消费、投资等包含的内容国民收入的其他衡量指标 国内生产总值（GDP） 国内生产净值（NDP） 国民收入（NI） 个人收入（PI） 个人可支配收入（DPI） 各部门储蓄-投资恒等式 两部门 C+I = Y = C+S 三部门 Y = C+I+G 四部门 Y = C+I+G+(X-M) 国民收入的决定：收入——支出 模型 均衡产出 和总需求相等的产出成为均衡产出或收入 y = c+i 也就是经济社会的收入正好等于全体居民和企业想要有的支出 消费倾向 消费函数（消费倾向）：随着收入的战甲，消费也会增加，但是消费的增加不及收入的增加多 边际消费倾向（MPC）：增加的消费与最佳的收入之比率 MPC = dc/dy 平均消费倾向（APC）：任一收入水平上消费支出在收入中的比率 凯恩斯消费理论 消费函数 边际消费倾向递减，如果消费和收入之间存在线性关系，则边际消费倾向为一常数，这时消费函数表示为C=α+β 储蓄函数 s = y-c = y-(α+β)y = -α+(1-β)y 乘数 两部门经济中收入决定 消费函数决定收入 由于 y = c+i（收入恒等式） c = α+βy（消费函数） 联立得到 y = (α+i)/(1-β)（均衡收入） 可见，如果知道了消费函数和投资量，就可以得到均衡的国民收入 储蓄函数决定收入 由于 i = s = y-c（投资等于储蓄） s = -α+(1-β)y（储蓄函数） 联立得到 y = (α+i)/(1-β)（均衡收入） 乘数论 投资乘数指收入的变化与带来这种变化的投资支出的变化的比率 三部门经济中的各种乘数及其局限性 收入决定（三部门宏观均衡） i+g = s+t 乘数 y = (α+i+g-βt)/(1-β) IS-LM模型 IS曲线 I=e-dr 斜率绝对值 d对IS曲线的影响 β对IS曲线的影响 LM曲线 公式 定义 曲线图 斜率 &amp; h 产品市场和货币市场的一般均衡 AD-AS模型 总需求曲线为什么是向右下倾斜（三种效应） 利率效应 价格水平上升是，实际货币供给下降，货币供给小于货币需求，导致利率上升，投资下降，总需求量减少 实际越效应 价格总水平上升是，资产实际价值下降，人们实际拥有的财富减少，人们的消费水平下降 税收效应 价格总水平上升是，人们的名义收入水平增加，会使人们进入更高的纳税等级，从而增加人们的税收负担，减少可支配收入，进而减少消费 失业与通货膨胀三种失业类型 摩擦性失业 由于一些原因，工人在工作搜寻过程中所引起的失业 结构性失业 劳动力的供给和需求不匹配（又有失业，又有职位空缺） 周期性失业（非重点） 整体经济的支出和产出水平下架，即经济的需求下降而造成的失业 通货膨胀 作为货币现象的通货膨胀 货币数量论交易方程：Py=MV M为货币供给量；V为货币流通速度；P为价格水平：y为实际收入水平 Π = m-y+v Π为通货膨胀率；m为货币增长率；y为产品增长率；v为货币流通速度变化率 需求拉动的通货膨胀（瓶颈现象） 成本推动的通货膨胀 指在没有超额需求的情况下由于供给方面成本提高所引起的一般价格水平持续和显著上涨 工资-价格螺旋 结构性通货膨胀（经济结构因素影响） 通货膨胀的成本 预期到的通货膨胀 菜单成本 调整价格的成本 鞋底成本 往返银行路上所画的时间和汽油钱等开支 税收扭曲 相对价格变动导致的资源配置不当 混乱与不方便 未预期到的通货膨胀成本 不确定性的增加 不合意的财富的再分配 相对价格变动性的增加 通货膨胀的影响 不利于固定收入 倾向于储蓄人 不利于债权人 有利于债务人 菲利普斯曲线的短期效果 u与Π成相反关系 总需求低 低通货膨胀 高失业率 总需求高 高通货膨胀 低失业率 菲利普斯曲线的长期表现 垂直于自然失业率水平的长期菲利普斯曲线表明，在长期中，不存在失业与通货膨胀的替换关系 宏观经济政策财政政策及货币政策的定义 财政政策 财政政策 是 政府变动税收和支出以便影响总需求进而影响就业和国民收入的政策 货币政策 货币政策 是 货币当局即中央银行通过银行体系变动货币供给量来调节总需求 自动稳定器的定义及其三项制度 定义 指经济系统本身存在的一种会减少各种干扰对国民收入的冲击的机制，能够在经济繁荣时期自动抑制通货膨胀，在经济衰退时期自动减轻萧条，无须政府采取任何行动 三项制度 政府税收的自动变化 政府转移支付的自动变化 农产品价格维持制度 财政政策的IS-LM图形分析 &amp; 货币政策的IS-LM图形分析 财政政策 “挤出效应”是指政府支出增加所引起的私人消费或投资降低的效果（LM曲线不变，IS曲线斜率越小，越平坦，效果越强） IS曲线不变，LM曲线斜率越大，国民收入增量越少，即政策效果越小 货币政策 LM曲线形状不变，IS曲线越平坦，LM移动的影响越大 IS曲线斜率不变，LM曲线越平坦，货币政策效果越小 财政政策的局限性 如果经济处于投资对利率高度敏感而货币需求对利率不敏感的状态，即使支出乘数很大也无法使财政政策有效 存款综合，货币创造乘数 一国之内的货币供应量，绝大部分是商业银行创造的存款货币 货币政策及其工具 特点 再贴现率政策（中央银行对其他金融机构放款利率） 公开市场业务（中央银行公开买卖政府债券以可支货币供给和利率） 变动法定准备率（增加货币供给，降低法定准备率） 调整手段 调整实际利率为主要依据和中介目标 局限性 经济衰退时期 货币流通速度不会不变 货币政策外部时滞 资金在国际上流动]]></content>
  </entry>
  <entry>
    <title><![CDATA[[原]HPU lib 河南理工大学图书馆 已借书籍爬取 Python]]></title>
    <url>%2F2018%2F08%2F30%2F%E5%8E%9F-HPU-lib-%E6%B2%B3%E5%8D%97%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A6%E5%9B%BE%E4%B9%A6%E9%A6%86-%E5%B7%B2%E5%80%9F%E4%B9%A6%E7%B1%8D%E7%88%AC%E5%8F%96-Python%2F</url>
    <content type="text"><![CDATA[看了下我们学校图书馆，顺手爬个已借书籍 一开始把学校想得没那么简单，尝试模拟登录，提交表单里面出现了一堆奇奇怪怪的东西，查了一下发现是.net生成的，又花了一会时间去抓这个参数 最后，emmmm，没毛病，筛子系统果然cookies就能过，真是暴力 `import requests from bs4 import BeautifulSoup def main(): headers = { 'User-Agent': 'Mozilla / 5.0(X11;Linux x86_64) AppleWebKit / 537.36(KHTML, like Gecko) Ubuntu Chromium / 68.0.3440.106 Chrome / 68.0.3440.106 Safari / 537.36', 'Cookie': 'ASP.NET_SessionId=dnlcydvvqwnc3yax1ymja2ji', } wb_data = requests.get('http://218.196.244.90:8080/Borrowing.aspx', headers = headers) soup = BeautifulSoup(wb_data.text, 'lxml') titles = soup.select('#ctl00_ContentPlaceHolder1_GridView1_ctl0{}_HyperLink1'.format(str(3)) #format从2开始到你借的书数量+1) print(titles) main()` 这里没对输出处理 [&lt;a href=”Book.aspx?id=0199151729” id=”ctl00_ContentPlaceHolder1_GridView1_ctl03_HyperLink1” style=”color:#980000;color: #800000; font-weight: 700; font-size: small;” title=”海边的卡夫卡”&gt;海边的卡夫卡&lt;/a&gt;] 有空再继续阿​ ​ 作者：Jqmjyj 发表于 2018/08/30 21:12:51 原文链接 https://blog.csdn.net/Jqmjyj/article/details/82227785 ​ ​ 阅读：103]]></content>
  </entry>
  <entry>
    <title><![CDATA[[原]codeforces round #306 div2 B Preparing Olympiad &amp;&amp; HPU SummerCamp round6 B 二进制枚举]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%8E%9F-codeforces-round-306-div2-B-Preparing-Olympiad-amp-amp-HPU-SummerCamp-round6-B-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[被隔壁oi爷暴打的一场校内赛，这道水题没做出来http://codeforces.com/contest/550/problem/B You have _n_ problems. You have estimated the difficulty of the _i_-th one as integer c__i. Now you want to prepare a problemset for a contest, using some of the problems you’ve made. A problemset for the contest must consist of at least two problems. You think that the total difficulty of the problems of the contest must be at least _l_ and at most _r_. Also, you think that the difference between difficulties of the easiest and the hardest of the chosen problems must be at least _x_. Find the number of ways to choose a problemset for the contest. Input The first line contains four integers _n_, _l_, _r_, _x_ (1 ≤ _n_ ≤ 15, 1 ≤ _l_ ≤ _r_ ≤ 109, 1 ≤ _x_ ≤ 106) — the number of problems you have, the minimum and maximum value of total difficulty of the problemset and the minimum difference in difficulty between the hardest problem in the pack and the easiest one, respectively. The second line contains _n_ integers _c_1, _c_2, …, c__n (1 ≤ c__i ≤ 106) — the difficulty of each problem. Output Print the number of ways to choose a suitable problemset for the contest. Examples input 3 5 6 1 1 2 3 output 2 input 4 40 50 10 10 20 30 25 output 2 input 5 25 35 10 10 10 20 10 20 output 6 Note In the first example two sets are suitable, one consisting of the second and third problem, another one consisting of all three problems. In the second example, two sets of problems are suitable — the set of problems with difficulties 10 and 30 as well as the set of problems with difficulties 20 and 30. In the third example any set consisting of one problem of difficulty 10 and one problem of difficulty 20 is suitable. 一开始没想到二进制枚举，sb一样看队友在那写for循环， 啊啊啊啊 这道题就是简单的二进制枚举 乘机补一下二进制枚举，原理是利用二进制每一位有0和1两种状态，从0枚举到 `//---JQM---// #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;cmath&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;stack&gt; #include &lt;queue&gt; #define INF 0x3f3f3f3f using namespace std; typedef long long ll; typedef unsigned long long ull; int c[30]; int main() { int t, i, n, l, r, x, maxx, minn, ans, sum; cin&gt;&gt;t; //codeforces上此题没有t while(t--) //codeforces上此题没有t { ans = 0; scanf("%d%d%d%d", &amp;n, &amp;l, &amp;r, &amp;x); for(i=0; i&lt;n; i++) scanf("%d", &amp;c[i]); int temp = 1&lt;&lt;n; for(i=0; i&lt;temp; i++) //每一个i代表不同的情况 { maxx = 0; minn = INF; sum = 0; for(int j=0; j&lt;n; j++) if(i&amp;(1&lt;&lt;j)) //判断二进制i的每一位是否为1，不是则跳过 { sum += c[j]; maxx = max(maxx, c[j]); minn = min(minn, c[j]); } if(sum&lt;=r &amp;&amp; sum&gt;= l &amp;&amp; maxx-minn&gt;=x) ans++; } cout&lt;&lt;ans&lt;&lt;endl; } return 0; }` &lt;div&gt; 作者：Jqmjyj 发表于 2018/08/28 19:09:15 [原文链接](https://blog.csdn.net/Jqmjyj/article/details/82152851) https://blog.csdn.net/Jqmjyj/article/details/82152851 &lt;/div&gt; &lt;div&gt; 阅读：32 &lt;/div&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[[原]牛客练习赛25 A 签到题 因数个数和]]></title>
    <url>%2F2018%2F08%2F24%2F%E5%8E%9F-%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B25-A-%E7%AD%BE%E5%88%B0%E9%A2%98-%E5%9B%A0%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C%2F</url>
    <content type="text"><![CDATA[链接：https://www.nowcoder.com/acm/contest/158/A 来源：牛客网 题目描述q次询问，每次给一个x，问1到x的因数个数的和。 输入描述: 第一行一个正整数q ； 接下来q行，每行一个正整数 x 输出描述: 共q行，每行一个正整数表示答案 示例1 输入复制 4 1 2 3 10 输出复制 1 3 5 27 说明 1的因数有1 2的因数有1,2 3的因数有1,3 以此类推 备注: 1&lt;=q&lt;=10 ,1&lt;= x&lt;=109 一开始想打表仔细一看是1加到x，显然不行 启用oeis公式 代码如下 `//---JQM---// #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;cmath&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;stack&gt; #include &lt;queue&gt; #define INF 0x3f3f3f3f using namespace std; typedef long long ll; typedef unsigned long long ull; ll yin(ll n) { ll l, temp; ll ans = 0; for( l = 1; l &lt;= n; l = temp+1) { temp = n/(n/l); ans += n/l * (temp - l + 1); } return ans; } int main() { int t; cin&gt;&gt;t; while(t--) { ll x; cin&gt;&gt; x; cout&lt;&lt;yin(x)&lt;&lt;endl; } }` 赛后出了官方题解，大概是这个意思：把因数个数和转化为倍数个数和，即 &lt;div&gt; 作者：Jqmjyj 发表于 2018/08/24 22:34:17 [原文链接](https://blog.csdn.net/Jqmjyj/article/details/82026073) https://blog.csdn.net/Jqmjyj/article/details/82026073 &lt;/div&gt; &lt;div&gt; 阅读：115 评论：8 [查看评论](https://blog.csdn.net/Jqmjyj/article/details/82026073#comments) &lt;/div&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[[原]CodeForces - 893C Rumor 并查集]]></title>
    <url>%2F2018%2F08%2F24%2F%E5%8E%9F-CodeForces-893C-Rumor-%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[链接http://codeforces.com/problemset/problem/893/C C. Rumor time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output Vova promised himself that he would never play computer games… But recently Firestorm — a well-known game developing company — published their newest game, World of Farcraft, and it became really popular. Of course, Vova started playing it. Now he tries to solve a quest. The task is to come to a settlement named Overcity and spread a rumor in it. Vova knows that there are _n_ characters in Overcity. Some characters are friends to each other, and they share information they got. Also Vova knows that he can bribe each character so he or she starts spreading the rumor; _i_-th character wants c__i gold in exchange for spreading the rumor. When a character hears the rumor, he tells it to all his friends, and they start spreading the rumor to their friends (for free), and so on. The quest is finished when all _n_ characters know the rumor. What is the minimum amount of gold Vova needs to spend in order to finish the quest? Take a look at the notes if you think you haven’t understood the problem completely. Input The first line contains two integer numbers _n_ and _m_ (1 ≤ _n_ ≤ 105, 0 ≤ _m_ ≤ 105) — the number of characters in Overcity and the number of pairs of friends. The second line contains _n_ integer numbers c__i (0 ≤ c__i ≤ 109) — the amount of gold _i_-th character asks to start spreading the rumor. Then _m_ lines follow, each containing a pair of numbers (x__i, y__i) which represent that characters x__i and y__i are friends (1 ≤ x__i, y__i ≤ _n_, x__i ≠ y__i). It is guaranteed that each pair is listed at most once. Output Print one number — the minimum amount of gold Vova has to spend in order to finish the quest. Examples Input Copy 5 2 2 5 3 4 8 1 4 4 5 Output Copy 10 Input Copy 10 0 1 2 3 4 5 6 7 8 9 10 Output Copy 55 Input Copy 10 5 1 6 2 7 3 8 4 9 5 10 1 2 3 4 5 6 7 8 9 10 Output Copy 15 Note In the first example the best decision is to bribe the first character (he will spread the rumor to fourth character, and the fourth one will spread it to fifth). Also Vova has to bribe the second and the third characters, so they know the rumor. In the second example Vova has to bribe everyone. In the third example the optimal decision is to bribe the first, the third, the fifth, the seventh and the ninth characters. 保证每一个团体中贿赂的钱都是其中最便宜的那个注意数据范围和long long `//---JQM---// #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;cmath&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;stack&gt; #include &lt;queue&gt; #define INF 0x3f3f3f3f using namespace std; typedef long long ll; typedef unsigned long long ull; #define maxn 100050 //int fa[maxn]; ll ans; struct stu { int fa, val; }fa[maxn]; int find(int x) { if(fa[x].fa==x) return x; return fa[x].fa = find(fa[x].fa); } int join(int x, int y) { int f1 = find(x); int f2 = find(y); if(f1!=f2) { fa[f1].fa = f2; fa[f2].val = min(fa[f1].val, fa[f2].val); fa[f1].val = 0; return 1; } return 0; } int main() { int n, m, i, x, y; cin&gt;&gt;n&gt;&gt;m; for(i=1; i&lt;=n; i++) { fa[i].fa = i; scanf("%d", &amp;fa[i].val); } ans = 0; for(i=1; i&lt;=m; i++) { scanf("%d%d", &amp;x, &amp;y); join(x, y); } for(i=1; i&lt;=n; i++) { ans += fa[i].val; } cout&lt;&lt;ans&lt;&lt;endl; return 0; }` &lt;div&gt; 作者：Jqmjyj 发表于 2018/08/24 15:40:20 [原文链接](https://blog.csdn.net/Jqmjyj/article/details/82019888) https://blog.csdn.net/Jqmjyj/article/details/82019888 &lt;/div&gt; &lt;div&gt; 阅读：54 &lt;/div&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[[原]牛客wannaflay挑战赛22 签到题 计数器 &amp;&amp; Wolf and Rabbit HDU 1222]]></title>
    <url>%2F2018%2F08%2F24%2F%E5%8E%9F-%E7%89%9B%E5%AE%A2wannaflay%E6%8C%91%E6%88%98%E8%B5%9B22-%E7%AD%BE%E5%88%B0%E9%A2%98-%E8%AE%A1%E6%95%B0%E5%99%A8-amp-amp-Wolf-and-Rabbit-HDU-1222%2F</url>
    <content type="text"><![CDATA[这链接真特么难找 链接：https://www.nowcoder.com/acm/contest/160/A 来源：牛客网 时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format: %lld 题目描述有一个计数器，计数器的初始值为0，每次操作你可以把计数器的值加上a1,a2,…,an中的任意一个整数，操作次数不限（可以为0次），问计数器的值对m取模后有几种可能。 输入描述: `第一行两个整数n,m 接下来一行n个整数表示a1,a2,...,an 1≤n≤100 1≤m,a1,a2,...,an≤1000000000` 输出描述: `输出一个整数表示答案` 示例1 输入复制 `3 6 6 4 8` 输出复制 `3` 求出所有数的公共gcd，即每次可以多出多少（注意第一次要和m进行gcd） `#include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;iostream&gt; using namespace std; int main() { int n, m, i; cin&gt;&gt;n&gt;&gt;m; int x = m; int a; for(i=0; i&lt;n; i++){ cin&gt;&gt;a; x = __gcd(a, x); } cout&lt;&lt;m/x&lt;&lt;endl; return 0; }` 类似思想在hdu1222http://acm.hdu.edu.cn/showproblem.php?pid=1222 解法差不多，但是这个题面更容易理解 Problem Description There is a hill with n holes around. The holes are signed from 0 to n-1. A rabbit must hide in one of the holes. A wolf searches the rabbit in anticlockwise order. The first hole he get into is the one signed with 0. Then he will get into the hole every m holes. For example, m=2 and n=6, the wolf will get into the holes which are signed 0,2,4,0. If the rabbit hides in the hole which signed 1,3 or 5, she will survive. So we call these holes the safe holes. Input The input starts with a positive integer P which indicates the number of test cases. Then on the following P lines,each line consists 2 positive integer m and n(0&lt;m,n&lt;2147483648). Output For each input m n, if safe holes exist, you should output “YES”, else output “NO” in a single line. Sample Input 2 1 2 2 2 Sample Output NO YES `#include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int main() { int T; scanf("%d",&amp;T); while(T--) { int n,m; scanf("%d%d",&amp;m,&amp;n); if(__gcd(m,n)==1) puts("NO"); else puts("YES"); } return 0; }` &lt;div&gt; 作者：Jqmjyj 发表于 2018/08/24 08:23:58 [原文链接](https://blog.csdn.net/Jqmjyj/article/details/82011054) https://blog.csdn.net/Jqmjyj/article/details/82011054 &lt;/div&gt; &lt;div&gt; 阅读：43 &lt;/div&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[[原]洛谷P1056排座椅 简单模拟]]></title>
    <url>%2F2018%2F08%2F23%2F%E5%8E%9F-%E6%B4%9B%E8%B0%B7P1056%E6%8E%92%E5%BA%A7%E6%A4%85-%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[题目描述上课的时候总会有一些同学和前后左右的人交头接耳，这是令小学班主任十分头疼的一件事情。不过，班主任小雪发现了一些有趣的现象，当同学们的座次确定下来之后，只有有限的D对同学上课时会交头接耳。 同学们在教室中坐成了 MMM 行 NNN 列，坐在第i行第j列的同学的位置是 (i,j)(i,j)(i,j) ，为了方便同学们进出，在教室中设置了 KKK 条横向的通道， LLL 条纵向的通道。 于是，聪明的小雪想到了一个办法，或许可以减少上课时学生交头接耳的问题：她打算重新摆放桌椅，改变同学们桌椅间通道的位置，因为如果一条通道隔开了 222 个会交头接耳的同学，那么他们就不会交头接耳了。 请你帮忙给小雪编写一个程序，给出最好的通道划分方案。在该方案下，上课时交头接耳的学生的对数最少。 输入输出格式输入格式： 第一行，有 555 个用空格隔开的整数，分别是 M,N,K,L,D(2≤N,M≤1000,0≤K&lt;M,0≤L&lt;N,D≤2000)M,N,K,L,D(2 \le N,M \le 1000,0 \le K&lt;M,0 \le L&lt;N,D \le 2000)M,N,K,L,D(2≤N,M≤1000,0≤K&lt;M,0≤L&lt;N,D≤2000) 接下来的 DDD 行，每行有 444 个用空格隔开的整数。第 iii 行的 444 个整数 Xi,Yi,Pi,QiX_i,Y_i,P_i,Q_iXi​,Yi​,Pi​,Qi​ ，表示坐在位置 (Xi,Yi)(X_i,Y_i)(Xi​,Yi​) 与 (Pi,Qi)(P_i,Q_i)(Pi​,Qi​) 的两个同学会交头接耳（输入保证他们前后相邻或者左右相邻）。 输入数据保证最优方案的唯一性。 输出格式： 共两行。 第一行包含 KKK 个整数 a1,a2,…,aKa_1,a_2,…,a_Ka1​,a2​,…,aK​ ，表示第 a1a_1a1​ 行和 a1+1a_1+1a1​+1 行之间、第 a−2a-2a−2 行和 a2+1a_2+1a2​+1 行之间、…、第 aKa_KaK​ 行和第 aK+1a_K+1aK​+1 行之间要开辟通道，其中 ai&lt;ai+1a_i&lt; a_i+1ai​&lt;ai​+1 ，每两个整数之间用空格隔开（行尾没有空格）。 第二行包含 LLL 个整数 b1,b2,…,bLb_1,b_2,…,b_Lb1​,b2​,…,bL​ ，表示第 b1b_1b1​ 列和 b1+1b_1+1b1​+1 列之间、第 b2b_2b2​ 列和 b2+1b_2+1b2​+1 列之间、…、第 bLb_LbL​ 列和第 bL+1b_L+1bL​+1 列之间要开辟通道，其中 bi&lt;bi+1b_i&lt; b_i+1bi​&lt;bi​+1 ，每两个整数之间用空格隔开（列尾没有空格）。 输入输出样例输入样例#1： 复制 4 5 1 2 3 4 2 4 3 2 3 3 3 2 5 2 4 输出样例#1： 复制 2 2 4 `#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;set&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; #define maxn 10000 struct stu { int x, cnt; }; bool fcmp(stu a, stu b) { return a.cnt&gt;b.cnt; } bool cmp(stu a, stu b) { return a.x&lt;b.x; } int main() { int m, n, k, l, d, i; int x, y, p, q; cin&gt;&gt;m&gt;&gt;n&gt;&gt;k&gt;&gt;l&gt;&gt;d; stu a[maxn], b[maxn]; int flag1=0, flag2=0; for(i=0; i&lt;d; i++) { int j; scanf("%d%d%d%d", &amp;x, &amp;y, &amp;p, &amp;q); if(y==q) { j = min(x, p); a[j].x = j; a[j].cnt++; } else { j = min(y, q); b[j].x = j; b[j].cnt++; } } sort(a, a+d, fcmp); sort(a, a+k, cmp); sort(b, b+d, fcmp); sort(b, b+l, cmp); for(i=0; i&lt;k; i++) { if(i) cout&lt;&lt;' '; cout&lt;&lt;a[i].x; }cout&lt;&lt;endl; for(i=0; i&lt;l; i++) { if(i) cout&lt;&lt;' '; cout&lt;&lt;b[i].x; }cout&lt;&lt;endl; return 0; }` &lt;div&gt; 作者：Jqmjyj 发表于 2018/08/23 14:25:48 [原文链接](https://blog.csdn.net/Jqmjyj/article/details/81980258) https://blog.csdn.net/Jqmjyj/article/details/81980258 &lt;/div&gt; &lt;div&gt; 阅读：115 &lt;/div&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[[原]map.size() 洛谷P1540 简单模拟]]></title>
    <url>%2F2018%2F08%2F23%2F%E5%8E%9F-map-size-%E6%B4%9B%E8%B0%B7P1540-%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[题目背景小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。 题目描述这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。 假设内存中有 MMM 个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过 M−1M-1M−1 ，软件会将新单词存入一个未使用的内存单元；若内存中已存入 MMM 个单词，软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。 假设一篇英语文章的长度为 NNN 个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？假设在翻译开始前，内存中没有任何单词。 输入输出格式输入格式： 共 222 行。每行中两个数之间用一个空格隔开。 第一行为两个正整数 M,NM,NM,N ，代表内存容量和文章的长度。 第二行为 NNN 个非负整数，按照文章的顺序，每个数（大小不超过 100010001000 ）代表一个英文单词。文章中两个单词是同一个单词，当且仅当它们对应的非负整数相同。 输出格式： 一个整数，为软件需要查词典的次数。 输入输出样例输入样例#1： 复制 `3 7 1 2 1 5 4 4 1 ` 输出样例#1： 复制 `5 ` 这道题很简单啊，代码就不贴了，用到了map 写这题主要是因为突然发现map中的值就算赋值为0也还是算在size()中啊，应该erase()，以前一直以为只要赋值0就相当于空了（捂脸） 作者：Jqmjyj 发表于 2018/08/23 09:32:22 原文链接 https://blog.csdn.net/Jqmjyj/article/details/81974679 阅读：59]]></content>
  </entry>
  <entry>
    <title><![CDATA[[原]HDU1754 I Hate It]]></title>
    <url>%2F2018%2F08%2F21%2F%E5%8E%9F-HDU1754-I-Hate-It%2F</url>
    <content type="text"><![CDATA[链接http://acm.hdu.edu.cn/showproblem.php?pid=1754 Problem Description 很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。 这让很多学生很反感。 不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。 Input 本题目包含多组测试，请处理到文件结束。 在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。 学生ID编号分别从1编到N。 第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。 接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。 当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。 当C为’U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。 Output 对于每一次询问操作，在一行里面输出最高成绩。 Sample Input 5 6 1 2 3 4 5 Q 1 5 U 3 6 Q 3 4 Q 4 5 U 2 9 Q 1 5 Sample Output 5 6 5 9 Hint Huge input,the C function scanf() will work better than cin 这篇看了b站SWPU的教程，av9350697,链接https://www.bilibili.com/video/av9350697?from=search&amp;seid=7800936964375617671 `#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;iostream&gt; using namespace std; typedef long long ll; const int maxn = 2e6+10; struct stu { int l, r, v; }node[maxn&lt;&lt;2]; int father[maxn]; void build(int i, int l, int r) { node[i].l = l; node[i].r = r; node[i].v = 0; if(l == r) { father[l] = i; return ; } build(i&lt;&lt;1, l, (l+r)/2); build((i&lt;&lt;1)|1, (l+r)/2+1, r); } void update(int ri) { if(ri==1) return ; int fi = ri/2; int a = node[fi&lt;&lt;1].v; int b = node[(fi&lt;&lt;1)|1].v; node[fi].v = max(a, b); update(fi); } int maax; void query(int i, int l, int r) { if(node[i].l == l &amp;&amp; node[i].r ==r) { maax = max(maax, node[i].v); return ; } i = i&lt;&lt;1; if(l&lt;=node[i].r) { if(r&lt;=node[i].r) query(i, l, r); else query(i, l, node[i].r); } i++; if(r&gt;=node[i].l) { if(l&gt;=node[i].l) query(i, l, r); else query(i, node[i].l, r); } } int main() { int n, m, i, t; cin&gt;&gt;t; char s[10]; while(t--) { scanf("%d%d", &amp;n, &amp;m); int x, y; build(1, 1, n); for(i=1; i&lt;=n; i++) { scanf("%d", &amp;x); node[father[i]].v = x; update(father[i]); } while(m--) { scanf("%s%d%d", s, &amp;x, &amp;y); if(s[0]=='Q') { maax = 0; query(1, x, y); cout&lt;&lt;maax&lt;&lt;endl; } else { node[father[x]].v = y; update(father[x]); } } } return 0; }` &lt;div&gt; 作者：Jqmjyj 发表于 2018/08/21 16:24:45 [原文链接](https://blog.csdn.net/Jqmjyj/article/details/81909779) https://blog.csdn.net/Jqmjyj/article/details/81909779 &lt;/div&gt; &lt;div&gt; 阅读：51 &lt;/div&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[[原]sublime ubuntu &amp;&amp; windows 配置 注册]]></title>
    <url>%2F2018%2F08%2F19%2F%E5%8E%9F-sublime-ubuntu-amp-amp-windows-%E9%85%8D%E7%BD%AE-%E6%B3%A8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[Windows 12345678910111213141516171819202122&#123;"cmd": ["gcc","-Wall", "$&#123;file&#125;", "-o", "$&#123;file_path&#125;/$&#123;file_base_name&#125;"],"file_regex": "^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$","working_dir": "$&#123;file_path&#125;","selector": "source.c, source.c++","encoding":"cp936","variants":[&#123;"name": "Run","cmd": ["cmd", "/c", "gcc", "-Wall","$&#123;file&#125;", "-o", "$&#123;file_path&#125;/$&#123;file_base_name&#125;", "&amp;&amp;", "cmd", "/c", "$&#123;file_path&#125;/$&#123;file_base_name&#125;"]&#125;,&#123;"name": "RunInCommand","cmd": ["cmd", "/c", "gcc", "-Wall","$&#123;file&#125;", "-o", "$&#123;file_path&#125;/$&#123;file_base_name&#125;", "&amp;&amp;", "start", "cmd", "/c", "$&#123;file_path&#125;/$&#123;file_base_name&#125; &amp; echo.&amp;pause"]&#125;,&#123;"name": "RunInShell","shell_cmd": " start cmd /c \"\"$&#123;file_path&#125;/$&#123;file_base_name&#125;\"&amp;pause\" "&#125;]&#125; Ubuntu 12345"cmd" : ["gnome-terminal - bash -c \"g++ $file_name -o $&#123;file_base_name&#125; -lm -Wall; ./$&#123;file_base_name&#125;; exec bash\""],"selector" : "source.c, source.c++","shell":true,"working_dir" : "$file_path"&#125; Tools-&gt;Build System-&gt;new Build System 加头文件snippetTools-&gt;Developer-&gt;new Snippet &lt;snippet&gt; &lt;content&gt;&lt;![CDATA[//—JQM—// #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;cmath&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;stack&gt; #include &lt;queue&gt; #define INF 0x3f3f3f3fusing namespace std;typedef long long ll;typedef unsigned long long ull;]]&gt;&lt;/content&gt; &lt;!– Optional: Set a tabTrigger to define how to trigger the snippet –&gt; &lt;!– &lt;tabTrigger&gt;hello&lt;/tabTrigger&gt; –&gt; &lt;tabTrigger&gt;header&lt;/tabTrigger&gt; &lt;!– Optional: Set a scope to limit where the snippet will trigger –&gt; &lt;!– &lt;scope&gt;source.python&lt;/scope&gt; –&gt;&lt;/snippet&gt; 18.8.25 update 关闭自动更新 及 注册Preferences-&gt;Settings 加入”update_check”: false, `{ "font_size": 17, "update_check": false, } ` 前提是你注册了 注册码 Help-&gt;Enter LIcense —– BEGIN LICENSE —–Michael BarnesSingle User LicenseEA7E-8213858A353C41 872A0D5C DF9B2950 AFF6F667C458EA6D 8EA3C286 98D1D650 131A97ABAA919AEC EF20E143 B361B1E7 4C8B7F04B085E65E 2F5F5360 8489D422 FB8FC1AA93F6323C FD7F7544 3F39C318 D95E6480FCCC7561 8A4A1741 68FA4223 ADCEDE07200C25BE DBBC4855 C4CFB774 C5EC138C0FEC1CEF D9DCECEC D3A5DAD1 01316C36—— END LICENSE —— 作者：Jqmjyj 发表于 2018/08/19 13:03:55 原文链接 https://blog.csdn.net/Jqmjyj/article/details/81837196 阅读：121]]></content>
  </entry>
  <entry>
    <title><![CDATA[[原]KMP hdu1686 poj3461 Oulipo]]></title>
    <url>%2F2018%2F08%2F18%2F%E5%8E%9F-KMP-hdu1686-poj3461-Oulipo%2F</url>
    <content type="text"><![CDATA[链接 pojhttp://poj.org/problem?id=3461 hduacm.hdu.edu.cn/showproblem.php?pid=1686 Description The French author Georges Perec (1936–1982) once wrote a book, La disparition, without the letter ‘e’. He was a member of the Oulipo group. A quote from the book: Tout avait Pair normal, mais tout s’affirmait faux. Tout avait Fair normal, d’abord, puis surgissait l’inhumain, l’affolant. Il aurait voulu savoir où s’articulait l’association qui l’unissait au roman : stir son tapis, assaillant à tout instant son imagination, l’intuition d’un tabou, la vision d’un mal obscur, d’un quoi vacant, d’un non-dit : la vision, l’avision d’un oubli commandant tout, où s’abolissait la raison : tout avait l’air normal mais… Perec would probably have scored high (or rather, low) in the following contest. People are asked to write a perhaps even meaningful text on some subject with as few occurrences of a given “word” as possible. Our task is to provide the jury with a program that counts these occurrences, in order to obtain a ranking of the competitors. These competitors often write very long texts with nonsense meaning; a sequence of 500,000 consecutive ‘T’s is not unusual. And they never use spaces. So we want to quickly find out how often a word, i.e., a given string, occurs in a text. More formally: given the alphabet {‘A’, ‘B’, ‘C’, …, ‘Z’} and two finite strings over that alphabet, a word _W_ and a text _T_, count the number of occurrences of _W_ in _T_. All the consecutive characters of W must exactly match consecutive characters of _T_. Occurrences may overlap. Input The first line of the input file contains a single number: the number of test cases to follow. Each test case has the following format: One line with the word _W_, a string over {‘A’, ‘B’, ‘C’, …, ‘Z’}, with 1 ≤ |_W_| ≤ 10,000 (here |_W_| denotes the length of the string _W_). One line with the text _T_, a string over {‘A’, ‘B’, ‘C’, …, ‘Z’}, with |_W_| ≤ |_T_| ≤ 1,000,000. Output For every test case in the input file, the output should contain a single number, on a single line: the number of occurrences of the word _W_in the text _T_. Sample Input 3 BAPC BAPC AZA AZAZAZA VERDI AVERDXIVYERDIAN Sample Output 1 3 0 魔改的kmp板子，可能还会有错 `#include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; const int maxn = 1e6+10; int n, m, cnt; char s1[maxn], s2[maxn]; int a[maxn]; void getnext() { int i=1, j=0; a[0] = 0; while(i&lt;m) { if(s2[i]==s2[j]) a[i++] = ++j; else if(!j) i++; else j = a[j-1]; } } int kmp() { int i=0, j=0; while(i&lt;n&amp;&amp;j&lt;m) { if(s1[i]==s2[j]) { i++; j++; } else if(!j) i++; else j = a[j-1]; if(j==m) { cnt++; j=a[j-1]; } } return cnt; } int main() { int t, i; cin&gt;&gt;t; while(t--) { scanf("%s", s2); scanf("%s", s1); m = strlen(s2); n = strlen(s1); getnext(); cnt = 0; cout&lt;&lt;kmp()&lt;&lt;endl; } return 0; }` &lt;div&gt; 作者：Jqmjyj 发表于 2018/08/18 11:03:40 [原文链接](https://blog.csdn.net/Jqmjyj/article/details/81806706) https://blog.csdn.net/Jqmjyj/article/details/81806706 &lt;/div&gt; &lt;div&gt; 阅读：27 &lt;/div&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[[原]小猪佩奇身上纹]]></title>
    <url>%2F2018%2F08%2F17%2F%E5%8E%9F-%E5%B0%8F%E7%8C%AA%E4%BD%A9%E5%A5%87%E8%BA%AB%E4%B8%8A%E7%BA%B9%2F</url>
    <content type="text"><![CDATA[更新一下效果图 2018-08-30 这个图在windows环境下我画不出来，也不知道是turtle哪里出的问题，笑苦 来自大佬 Monster12138 gayhub地址忘了。。。=-= 笑哭 `# coding:utf-8from turtle import* def nose(x,y):#鼻子 pu() goto(x,y) pd() seth(-30) begin_fill() a=0.4 for i in range(120): if 0&lt;=i&lt;30 or 60&lt;=i&lt;90: a=a+0.08 lt(3) #向左转3度 fd(a) #向前走a的步长 else: a=a-0.08 lt(3) fd(a) end_fill() pu() seth(90) fd(25) seth(0) fd(10) pd() pencolor(255,155,192) seth(10) begin_fill() circle(5) color(160,82,45) end_fill() pu() seth(0) fd(20) pd() pencolor(255,155,192) seth(10) begin_fill() circle(5) color(160,82,45) end_fill() def head(x,y):#头 color((255,155,192),”pink”) pu() goto(x,y) seth(0) pd() begin_fill() seth(180) circle(300,-30) circle(100,-60) circle(80,-100) circle(150,-20) circle(60,-95) seth(161) circle(-300,15) pu() goto(-100,100) pd() seth(-30) a=0.4 for i in range(60): if 0&lt;=i&lt;30 or 60&lt;=i&lt;90: a=a+0.08 lt(3) #向左转3度 fd(a) #向前走a的步长 else: a=a-0.08 lt(3) fd(a) end_fill() def ears(x,y): #耳朵 color((255,155,192),”pink”) pu() goto(x,y) pd() begin_fill() seth(100) circle(-50,50) circle(-10,120) circle(-50,54) end_fill() pu() seth(90) fd(-12) seth(0) fd(30) pd() begin_fill() seth(100) circle(-50,50) circle(-10,120) circle(-50,56) end_fill() def eyes(x,y):#眼睛 color((255,155,192),”white”) pu() seth(90) fd(-20) seth(0) fd(-95) pd() begin_fill() circle(15) end_fill() color(&quot;black&quot;) pu() seth(90) fd(12) seth(0) fd(-3) pd() begin_fill() circle(3) end_fill() color((255,155,192),&quot;white&quot;) pu() seth(90) fd(-25) seth(0) fd(40) pd() begin_fill() circle(15) end_fill() color(&quot;black&quot;) pu() seth(90) fd(12) seth(0) fd(-3) pd() begin_fill() circle(3) end_fill() def cheek(x,y):#腮 color((255,155,192)) pu() goto(x,y) pd() seth(0) begin_fill() circle(30) end_fill() def mouth(x,y): #嘴 color(239,69,19) pu() goto(x,y) pd() seth(-80) circle(30,40) circle(40,80) def body(x,y):#身体 color(“red”,(255,99,71)) pu() goto(x,y) pd() begin_fill() seth(-130) circle(100,10) circle(300,30) seth(0) fd(230) seth(90) circle(300,30) circle(100,3) color((255,155,192),(255,100,100)) seth(-135) circle(-80,63) circle(-150,24) end_fill() def hands(x,y):#手 color((255,155,192)) pu() goto(x,y) pd() seth(-160) circle(300,15) pu() seth(90) fd(15) seth(0) fd(0) pd() seth(-10) circle(-20,90) pu() seth(90) fd(30) seth(0) fd(237) pd() seth(-20) circle(-300,15) pu() seth(90) fd(20) seth(0) fd(0) pd() seth(-170) circle(20,90) def foot(x,y):#脚 pensize(10) color((240,128,128)) pu() goto(x,y) pd() seth(-90) fd(40) seth(-180) color(“black”) pensize(15) fd(20) pensize(10) color((240,128,128)) pu() seth(90) fd(40) seth(0) fd(90) pd() seth(-90) fd(40) seth(-180) color(&quot;black&quot;) pensize(15) fd(20) def tail(x,y):#尾巴 pensize(4) color((255,155,192)) pu() goto(x,y) pd() seth(0) circle(70,20) circle(10,330) circle(70,30) def setting(): #参数设置 pensize(4) hideturtle() colormode(255) color((255,155,192),”pink”) setup(840,500) speed(10) def main(): setting() #画布、画笔设置 nose(-100,100) #鼻子 head(-69,167) #头 ears(0,160) #耳朵 eyes(0,140) #眼睛 cheek(80,10) #腮 mouth(-20,30) #嘴 body(-32,-8) #身体 hands(-56,-45) #手 foot(2,-177) #脚 tail(148,-155) #尾巴 done() #结束 main()` 作者：Jqmjyj 发表于 2018/08/17 19:41:12 原文链接 https://blog.csdn.net/Jqmjyj/article/details/81782387 阅读：130]]></content>
  </entry>
  <entry>
    <title><![CDATA[[原]白书模板 poj2456 Aggressive cows]]></title>
    <url>%2F2018%2F08%2F17%2F%E5%8E%9F-%E7%99%BD%E4%B9%A6%E6%A8%A1%E6%9D%BF-poj2456-Aggressive-cows%2F</url>
    <content type="text"><![CDATA[基础二分 水题 http://poj.org/problem?id=2456 Description Farmer John has built a new long barn, with N (2 &lt;= N &lt;= 100,000) stalls. The stalls are located along a straight line at positions x1,…,xN (0 &lt;= xi &lt;= 1,000,000,000). His C (2 &lt;= C &lt;= N) cows don’t like this barn layout and become aggressive towards each other once put into a stall. To prevent the cows from hurting each other, FJ want to assign the cows to the stalls, such that the minimum distance between any two of them is as large as possible. What is the largest minimum distance? Input Line 1: Two space-separated integers: N and C Lines 2..N+1: Line i+1 contains an integer stall location, xi Output Line 1: One integer: the largest minimum distance Sample Input `5 3 1 2 8 4 9` Sample Output `3` Hint OUTPUT DETAILS: FJ can put his 3 cows in the stalls at positions 1, 4 and 8, resulting in a minimum distance of 3. Huge input data,scanf is recommended. `#include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; const int maxn = 1e6+10; int a[maxn]; int n, c; int check(int x) { int cnt = 1; int temp = a[0]; for(int i=1; i&lt;n; i++) { if(a[i]-temp&gt;=x) { cnt++; temp = a[i]; } if(cnt&gt;=c) break; } return cnt&gt;=c?1:0; } int main() { int i; while(cin&gt;&gt;n&gt;&gt;c) { for(i=0; i&lt;n; i++) { scanf("%d", &amp;a[i]); } sort(a, a+n); int l=0, m, r=a[n-1]-a[0]; while(r&gt;l+1) { m = (l+r)/2; if(check(m)) l = m; else r = m; } cout&lt;&lt;l&lt;&lt;endl; } return 0; }` 一开始输出了m，样列过了然后疯狂wa，发现取m可能超，应该用l 作者：Jqmjyj 发表于 2018/08/17 19:21:59 原文链接 https://blog.csdn.net/Jqmjyj/article/details/81782324 阅读：43]]></content>
  </entry>
  <entry>
    <title><![CDATA[[原]poj3461 Oulipo Hash || kmp]]></title>
    <url>%2F2018%2F08%2F17%2F%E5%8E%9F-poj3461-Oulipo-Hash-kmp%2F</url>
    <content type="text"><![CDATA[poj3461http://poj.org/problem?id=3461 hash模板题 Description The French author Georges Perec (1936–1982) once wrote a book, La disparition, without the letter ‘e’. He was a member of the Oulipo group. A quote from the book: Tout avait Pair normal, mais tout s’affirmait faux. Tout avait Fair normal, d’abord, puis surgissait l’inhumain, l’affolant. Il aurait voulu savoir où s’articulait l’association qui l’unissait au roman : stir son tapis, assaillant à tout instant son imagination, l’intuition d’un tabou, la vision d’un mal obscur, d’un quoi vacant, d’un non-dit : la vision, l’avision d’un oubli commandant tout, où s’abolissait la raison : tout avait l’air normal mais… Perec would probably have scored high (or rather, low) in the following contest. People are asked to write a perhaps even meaningful text on some subject with as few occurrences of a given “word” as possible. Our task is to provide the jury with a program that counts these occurrences, in order to obtain a ranking of the competitors. These competitors often write very long texts with nonsense meaning; a sequence of 500,000 consecutive ‘T’s is not unusual. And they never use spaces. So we want to quickly find out how often a word, i.e., a given string, occurs in a text. More formally: given the alphabet {‘A’, ‘B’, ‘C’, …, ‘Z’} and two finite strings over that alphabet, a word _W_ and a text _T_, count the number of occurrences of _W_ in _T_. All the consecutive characters of W must exactly match consecutive characters of _T_. Occurrences may overlap. Input The first line of the input file contains a single number: the number of test cases to follow. Each test case has the following format: One line with the word _W_, a string over {‘A’, ‘B’, ‘C’, …, ‘Z’}, with 1 ≤ |_W_| ≤ 10,000 (here |_W_| denotes the length of the string _W_). One line with the text _T_, a string over {‘A’, ‘B’, ‘C’, …, ‘Z’}, with |_W_| ≤ |_T_| ≤ 1,000,000. Output For every test case in the input file, the output should contain a single number, on a single line: the number of occurrences of the word _W_in the text _T_. Sample Input `3 BAPC BAPC AZA AZAZAZA VERDI AVERDXIVYERDIAN` Sample Output `1 3 0` 一开始做的时候直接用pow求得差基，忘了会爆了，笑哭 `#include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;set&gt; using namespace std; #define maxn 1000010 #define base 13333 typedef unsigned long long ull; char s1[10010]; char s2[maxn]; ull has2[maxn]; ull po[maxn]; void init() { po[0]=1; for(int i=1; i&lt;maxn; i++) po[i]=po[i-1]*base; } ull gethas(int i, int l, ull has0[]) { if(i==0) return has0[i+l-1]; return has0[i+l-1]-has0[i-1]*po[l]; //不能直接用pow，会爆，=-=忘了 } int main() { int t, i; cin&gt;&gt;t; init(); while(t--) { scanf("%s%s", s1, s2); ull has1 = 0; int len1 = strlen(s1), len2 = strlen(s2); for(i=0; i&lt;len1; i++) has1 = has1*base+s1[i]-'A'+1; has2[0] = s2[0]-'A'+1; for(i=1; i&lt;len2; i++) { has2[i] = has2[i-1]*base+s2[i]-'A'+1; } int ans = 0; for(i=0; i&lt;len2-len1+1; i++) { if(s2[i]==s1[0]) { if(gethas(i, len1, has2)==has1) ans++; } } cout&lt;&lt;ans&lt;&lt;endl; } return 0; }` 用数组存差基，has0[i+l-1]-has0[i-1]*po[l]返回一定范围的hash进行对比用ull直接取mod&lt;div&gt; 作者：Jqmjyj 发表于 2018/08/17 19:11:30 [原文链接](https://blog.csdn.net/Jqmjyj/article/details/81782220) https://blog.csdn.net/Jqmjyj/article/details/81782220 &lt;/div&gt; &lt;div&gt; 阅读：45 &lt;/div&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[[原]HDU1520 Anniversary party 不要超时]]></title>
    <url>%2F2018%2F08%2F10%2F%E5%8E%9F-HDU1520-Anniversary-party-%E4%B8%8D%E8%A6%81%E8%B6%85%E6%97%B6%2F</url>
    <content type="text"><![CDATA[HDU1520链接:http://acm.hdu.edu.cn/showproblem.php?pid=1520 百度了一堆过不了的wa代码，真是要哭哭出来了我去 比如某排第一的代码 `#include&lt;bits/stdc++.h&gt; using namespace std; int l,k,n,dp[6005][2],node,father[6005],isson[6005],vis[6005]; //dp[i][0] 不邀请i的最大值 //dp[i][1] 邀请i的最大值 void dfs(int root) { vis[root]=1; for(int i=1;i&lt;=n;i++) { if(vis[i]==0&amp;&amp;father[i]==root) { dfs(i); dp[root][1]+=dp[i][0]; dp[root][0]+=max(dp[i][1],dp[i][0]); } } } int main() { cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;dp[i][1]; } while(cin&gt;&gt;l&gt;&gt;k) { if(l==0&amp;&amp;k==0) break; father[l]=k; isson[l]++; } for(int i=1;i&lt;=n;i++) { if(isson[i]==0) { node=i; break; } } dfs(node); cout&lt;&lt;max(dp[node][1],dp[node][0]); return 0; }` 迷啊迷啊，超时啊 ac代码如下，主要卡了n的长度，找子节点的时候遍历会超时 `#include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; int n; int vis[6050], boss[6020], flag[6050]; int a[6050]; int dp[6050][2]; vector&lt;int&gt; ve[6050]; void dfs(int fa) { int i; dp[fa][1] = a[fa]; for(i=0; i&lt;ve[fa].size(); i++) //用vector而不用数组或者1-n遍历避免超时 { int l = ve[fa][i]; dfs(l); dp[fa][0] = max(dp[fa][0]+dp[l][0], dp[fa][0]+dp[l][1]); dp[fa][1] = dp[fa][1]+dp[l][0]; } } int main() { int i, l, k; while(~scanf("%d", &amp;n)) { memset(dp, 0, sizeof(dp)); for(i=1; i&lt;=n; i++) { scanf("%d", &amp;a[i]); ve[i].clear(); } while(scanf("%d%d", &amp;l, &amp;k) &amp;&amp; l &amp;&amp; k) { boss[l] = k; //flag[l] = 1; ve[k].push_back(l); } i = 1; while(boss[i]) i = boss[i]; dfs(i); cout&lt;&lt;max(dp[i][1], dp[i][0])&lt;&lt;endl; } return 0; }` &lt;div&gt; 作者：Jqmjyj 发表于 2018/08/10 17:42:23 [原文链接](https://blog.csdn.net/Jqmjyj/article/details/81567383) https://blog.csdn.net/Jqmjyj/article/details/81567383 &lt;/div&gt; &lt;div&gt; 阅读：41 &lt;/div&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F01%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
